<!DOCTYPE html>
<html>
<head>
	<!--#This will create an anonymous function that inserts a script into the DOM of the login.html page-->
	<script src = "//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
	<script src = "//apis.google.com/js/platform.js?onload=start"></script>
</head>

<body>
	<div id='signinButton'>
	<!--	put google developer console project id in data-clientid
		data-scope parameter specifies what google resources we want to be able to access. Google documentation for OpenId shows that it asks for name, email and profile picture. 

		data-redirecturi sets a post message, enables the one-time use code flow

		data-accesstype = offline means taht our server can make requests to Google API server even if the user is not logged in

		data-cookiepolicy determines the scope of the URIs that can access the cookie. We use the single host origin, if our website only has a single host name, and no subdomains

		data-callback parameter specifies a callback function. If a user clicks and grants our application access to their profile, this callback method is called, and given the one time use code along with an access token. 
		
		data-approvalprompt = force means that our user has to login each time we visit the login page and doesn't check to see if they're logged in already. Useful for debugging. Usually disabled for production as it can be annoying. -->

		<span class = 'g-signin'
		  data-scope = 'openid email'
		  data-clientid="293514612579-s550h7bb1ev9or9539bbjjbcqtut25mo.apps.googleusercontent.com"
		  data-redirecturi = 'postmessage'
		  data-accesstype='offline'
		  data-cookiepolicy='single_host_origin'
		  data-callback='signInCallback'
		  data-approvalprompt='force'>
		</span>
		</div>
	</div id="result"></div> <!--Empty div named result that we can populate with a response methond just above the opening script tag.<a href=" -->

	<script>
		function signInCallback(authResult) { // signin callback function takes in authResult object as input
			if(authResult['code']) { // if authResult contains parameter called code then we know that the authorization with Google API server was successful, and our one time use code is present.

				// Hide the sign-in button now that the user is authorized,
				$('#signinButton').attr('style','display:none');
				// Now send the one time use code to the server, if the server responds, write a 'login successful' message to the web page and then redirect back to the main restaurants page

				// Use jquery to create an AJAX call that passes the one time code google gave the cilent onto the server.
				$.ajax({
					type:'POST', // specify as a post method
					url: '/gconnect?state={{STATE}}', // Passing the state token as an argument to verify against a cross site reference forgery attack. Everything after the ? is a query string. So our function routing /gconnect will look for a variable called state and assign it the value STATE
					processData: false, // setting processData to false shows that we do not want jQuery to process the response into a string
					contentType: 'applicaton/octet-stream; charset=utf-8', // application/octet-stream indicates we are sending an arbitrary binary stream of data, charset=utf-8 indicates that it is formatted using a universal character set called Unicode
					data: authResult['code'], //specify data that we are going to send along to the server which will be the one time use code
					success: function(result) { // When we receive a 200 or successful response code from our server we will return a successful login message to the user and then redirect to the main restaurant's page after about four seconds.
						if (result) {
							$('#result').html('Login Successful!</br>') + result + '</br>Redirecting...')
							setTimeout(function(){
								window.location.href = '/restaurant';
							}, 4000);
						} else if (authResult['error']) { // If there was an error returned by Google, report the error to console.log
							console.log('There was an error: ' + authResult['error'])
						} else { // in the event that no response was returned by my server to the callback function, return this error message to the result div.
							$('#result').html('Failed to make a server-side call. Check your configuration and console.');
						}
					}

				});
			}
		}
	</script>
<!-- END GOOGLE PLUS SIGN IN -->

<!-- FACEBOOK SIGN IN -->
	<script>
		window.fbAsyncInit = function() {
			FB.init({
				appId : '1050769708298402'
				cookie: true // enables cookies to allow the server to access the session
				xfbml: true, // parse social plugins on this page
				version: 'v2.2' // user version 2.2
			});
		};

	// Load the SDK asynchronously
	(function(d,s,id) {
		var js, fjs = d.getElementsByTagName(s)[0];
		if (d.getElementById(id)) return;
		js = d.createElement(s); js.id = id;
		js.src = "//connect.facebook.net/en_US/sdk.js";
		fjs.parentNode.insertBefore(js,fjs);
	}(document,'script','facebook jssdk'));

	// Here we run a very simple test of the Graph API after login is successful. See statusChangeCallback() for when this call is made.
	function sendTokenToServer() {
		var access_token = FB.getAuthResponse()['accessToken']; // retreives short-lived access token
		console.log(access_token)
		console.log('Welcome! Fecthing your information... ');
		
		// Here it is just showing how to usethe FB SDK to make API calls
		FB.api('/me', function(response){
			console.log('Successful login for: ' + response.name);

			// Now we send the access token to the server via AJAX along with the state value
			$.ajax({
				type: 'POST',
				url: '/fbconnect?state={{STATE}}', // route is called FB connect which is implemented on client side.
				processData: false,
				data: access_token,
				contentType: 'application/octet-stream; charset=utf-8',
				success: function(result) {
					// Handle or verify the server response if necessary.
					if (result) {
						$('#result').html('Login Successful!</br>' + result + '</br>Redirecting...')
						setTimeout(function() {
							window.location.href = '/restaurant';
						}, 4000);

					} else {
						$('#result').html('Failed to make server-side call. Check your configuration and console.');
					}
				}
			});
		});
	}
	</script>

	<button>
		<!-- Use FB SDK to create FB login button. login-button scope specifies the scope of authorization the app can request. When button is clicked it (onlogin) it will invoke sendTokenToServer() method -->
		<fb:login-button scope="public_profile,email" onlogin="sendTokenToServer();">
		<a href = 'javascript:sendTokenToServer()'>Login with Facebook</a>
		</fb:login-button>
	</button>

</body>

</html>